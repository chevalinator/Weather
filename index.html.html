<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymarket Temperature Forecast Dashboard V2.2</title>

    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #333333;
            --text-primary: #ffffff;
            --text-secondary: #aaaaaa;
            --text-muted: #666666;
            --highlight: #ffb74d;
            --border: #333333;
            --error: #ff6b6b;
            --success: #4caf50;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Roboto', 'Segoe UI', Arial, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            padding: 20px;
            line-height: 1.6;
        }

        .container { max-width: 1200px; margin: 0 auto; }

        header { text-align: center; margin-bottom: 40px; }

        h1 { font-size: 28px; font-weight: 700; margin-bottom: 10px; color: var(--text-primary); }

        .subtitle { font-size: 14px; color: var(--text-secondary); }

        .controls {
            background-color: var(--bg-secondary);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .control-group { display: flex; flex-direction: column; gap: 8px; flex: 1; min-width: 200px; }

        label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select {
            padding: 12px 16px;
            font-size: 15px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
        }

        select:hover { border-color: var(--highlight); }
        select:focus { border-color: var(--highlight); box-shadow: 0 0 0 3px rgba(255, 183, 77, 0.2); }

        button {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            background-color: var(--highlight);
            color: var(--bg-primary);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            align-self: flex-end;
        }

        button:hover { background-color: #ffa726; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        .info-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 12px 16px;
            background-color: var(--bg-secondary);
            border-radius: 6px;
            font-size: 13px;
        }

        .info-bar .left { color: var(--text-secondary); }
        .info-bar .right { color: var(--text-muted); }

        .wunderground-link { color: var(--highlight); text-decoration: none; font-weight: 600; }
        .wunderground-link:hover { text-decoration: underline; }

        .table-container {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-bottom: 30px;
        }

        table { width: 100%; border-collapse: collapse; }
        thead { background-color: var(--bg-tertiary); }

        th {
            padding: 16px 20px;
            text-align: left;
            font-size: 13px;
            font-weight: 700;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid var(--border);
        }

        tbody tr { border-bottom: 1px solid var(--border); transition: background-color 0.2s ease; }
        tbody tr:hover { background-color: rgba(255, 183, 77, 0.05); }
        tbody tr:last-child { border-bottom: none; }

        td { padding: 16px 20px; font-size: 15px; }
        td:first-child { font-weight: 600; color: var(--text-primary); }
        td:nth-child(2) { font-weight: 700; font-size: 18px; color: var(--highlight); }
        td:nth-child(3) { font-family: 'Courier New', monospace; font-size: 13px; color: var(--text-secondary); }

        .model-link { color: var(--text-primary); text-decoration: none; transition: color 0.2s ease; }
        .model-link:hover { color: var(--highlight); text-decoration: underline; }

        /* Graph Section Styles */
        .graph-section { background-color: var(--bg-secondary); border-radius: 8px; padding: 20px; margin-bottom: 30px; }

        .graph-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .graph-header h2 { font-size: 20px; font-weight: 600; color: var(--text-primary); margin: 0; }

        .graph-controls { display: flex; gap: 10px; }

        .graph-controls button {
            padding: 8px 16px;
            font-size: 13px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .graph-controls button:hover {
            background-color: var(--highlight);
            color: var(--bg-primary);
            border-color: var(--highlight);
        }

        .chart-container { position: relative; height: 400px; margin-bottom: 20px; }

        .model-toggles {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .model-toggle-item { display: flex; align-items: center; gap: 8px; }

        .model-toggle-item input[type="checkbox"] {
            width: 18px; height: 18px; cursor: pointer; accent-color: var(--highlight);
        }

        .model-toggle-item label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            color: var(--text-secondary);
            user-select: none;
            transition: color 0.2s ease;
        }

        .model-toggle-item label:hover { color: var(--text-primary); }

        .color-indicator { width: 24px; height: 3px; border-radius: 2px; display: inline-block; }

        .loading { text-align: center; padding: 60px 20px; color: var(--text-secondary); }

        .loading-spinner {
            display: inline-block;
            width: 40px; height: 40px;
            border: 4px solid var(--bg-tertiary);
            border-top-color: var(--highlight);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .error {
            background-color: rgba(255, 107, 107, 0.1);
            border-left: 4px solid var(--error);
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .error-title { font-weight: 700; margin-bottom: 8px; color: var(--error); }
        .error-message { color: var(--text-secondary); font-size: 14px; }
        .no-data { text-align: center; padding: 60px 20px; color: var(--text-secondary); }

        /* Previous Runs Section Styles */
        .previous-runs-section {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .previous-runs-header { margin-bottom: 15px; }

        .previous-runs-header h2 {
            font-size: 20px; font-weight: 600; color: var(--text-primary); margin-bottom: 8px;
        }

        .previous-runs-header .subtitle {
            font-size: 13px; color: var(--text-secondary); line-height: 1.5;
        }

        .previous-runs-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .previous-runs-controls label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .previous-runs-controls select {
            padding: 6px 12px;
            font-size: 13px;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
        }

        /* Previous runs loading overlay */
        .previous-runs-loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .previous-runs-loading.active { display: block; }

        .legend-row {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            color: var(--text-secondary);
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .legend-item:hover { border-color: var(--highlight); color: var(--text-primary); }

        .legend-item.disabled {
            opacity: 0.35;
            border-color: var(--border);
        }

        .legend-item.disabled .legend-dot { background-color: #555 !important; }

        .legend-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }

        footer {
            margin-top: 60px;
            padding-top: 30px;
            border-top: 1px solid var(--border);
            text-align: center;
            color: var(--text-muted);
            font-size: 13px;
        }

        footer a { color: var(--highlight); text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        @media (max-width: 768px) {
            body { padding: 10px; }
            h1 { font-size: 22px; }
            .controls { flex-direction: column; }
            .control-group { width: 100%; min-width: auto; }
            button { width: 100%; align-self: stretch; }
            th, td { padding: 12px 12px; font-size: 14px; }
            td:nth-child(2) { font-size: 16px; }
            td:nth-child(3) { font-size: 12px; }
            .info-bar { flex-direction: column; gap: 10px; text-align: center; }
            .chart-container { height: 300px; }
            .graph-header { flex-direction: column; align-items: flex-start; }
            .graph-controls { width: 100%; }
            .graph-controls button { flex: 1; }
            .model-toggles { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>&#9925; Polymarket Temperature Forecast Dashboard V2.2</h1>
            <p class="subtitle">Compare weather model forecasts for betting decision support</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label for="location-select">Select Location</label>
                <select id="location-select" aria-label="Location selector">
                    <option value="0">Toronto (CYYZ)</option>
                    <option value="1">London (EGLC)</option>
                    <option value="2">Wellington (NZWN)</option>
                    <option value="3">Chicago (KORD)</option>
                    <option value="4">Dallas (KDAL)</option>
                    <option value="5">Seoul (RKSI)</option>
                    <option value="6">Buenos Aires (SAEZ)</option>
                    <option value="7">Sao Paulo (SBSP)</option>
                    <option value="8">Atlanta (KATL)</option>
                </select>
            </div>
            <button id="refresh-btn" aria-label="Refresh forecast data">&#128260; Refresh</button>
        </div>

        <div id="info-bar" class="info-bar" style="display: none;">
            <div class="left">
                <strong id="location-name"></strong> &bull; <span id="temperature-unit"></span>
            </div>
            <div class="right">
                Last updated: <span id="last-updated"></span> &bull;
                <a id="wunderground-link" href="#" target="_blank" rel="noopener noreferrer" class="wunderground-link">Weather Underground</a>
            </div>
        </div>

        <div id="error-container"></div>

        <!-- TABLE FIRST -->
        <div class="table-container">
            <table role="table" aria-label="Weather forecast comparison">
                <thead>
                    <tr>
                        <th scope="col">Model</th>
                        <th scope="col">High</th>
                        <th scope="col">Time (ISO 8601)</th>
                    </tr>
                </thead>
                <tbody id="forecast-body">
                    <tr>
                        <td colspan="3" class="loading">
                            <div class="loading-spinner"></div>
                            <div>Loading forecast data...</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- GRAPH SECTION BELOW TABLE -->
        <div class="graph-section">
            <div class="graph-header">
                <h2>&#128202; 24-Hour Temperature Forecast</h2>
                <div class="graph-controls">
                    <button id="toggle-all-models">Toggle All</button>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="temperature-chart"></canvas>
            </div>
            <div class="model-toggles" id="model-toggles">
                <!-- Dynamically generated checkboxes -->
            </div>
        </div>

        <!-- PREVIOUS RUNS SECTION -->
        <div class="previous-runs-section">
            <div class="previous-runs-header">
                <h2>&#128200; Previous Runs (Time-Lagged Ensemble)</h2>
                <p class="subtitle">
                    Shows how the forecast for the upcoming 24 hours has evolved over previous model runs.<br>
                    <strong>Consistent lines = High Confidence. Widely varying lines = High Uncertainty.</strong>
                </p>

                <div class="previous-runs-controls">
                    <label for="previous-runs-model-select">Model:</label>
                    <select id="previous-runs-model-select">
                        <option value="gem_hrdps_continental">GEM HRDPS 2.5km</option>
                        <option value="best_match">Best Match</option>
                        <option value="gfs_hrrr">HRRR 3km</option>
                        <option value="ecmwf_ifs025">ECMWF IFS 25km</option>
                        <option value="icon_seamless">ICON Seamless</option>
                        <option value="ukmo_seamless">UKMO Seamless</option>
                        <option value="meteofrance_arpege_world">MeteoFrance Arpege</option>
                        <option value="jma_seamless">JMA Seamless</option>
                        <option value="gfs_graphcast025">GraphCast AI</option>
                    </select>
                </div>

                <div class="legend-row" id="previous-runs-legend">
                    <!-- Dynamically populated -->
                </div>

                <div class="previous-runs-loading" id="previous-runs-loading">
                    <div class="loading-spinner" style="width:24px;height:24px;border-width:3px;"></div>
                    Loading previous runs...
                </div>
            </div>
            <div class="chart-container">
                <canvas id="previous-runs-chart"></canvas>
            </div>
        </div>

        <footer>
            <p>
                Data from <a href="https://open-meteo.com" target="_blank" rel="noopener noreferrer">Open-Meteo API</a> &bull;
                Polymarket resolves via <a href="https://www.wunderground.com" target="_blank" rel="noopener noreferrer">Weather Underground</a>
            </p>
            <p style="margin-top: 10px; font-size: 12px;">
                This tool shows model forecasts. Actual resolution depends on Weather Underground historical data.
            </p>
        </footer>
    </div>

    <script>
        const locations = [
            {
                city: "Toronto", icao: "CYYZ", lat: 43.712, lon: -79.655, unit: "celsius",
                wunderground: "https://www.wunderground.com/weather/ca/toronto-pearson-international/CYYZ",
                defaultModels: ["GEM HRDPS 2.5km", "HRRR 3km"],
                modelOrder: ["GEM HRDPS 2.5km", "HRRR 3km", "Best Match", "ECMWF IFS 25km", "ICON Seamless", "UKMO Seamless", "MeteoFrance Arpege", "JMA Seamless", "GraphCast AI"]
            },
            { city: "London",       icao: "EGLC", lat: 51.5053,  lon: 0.0553,    unit: "celsius",     wunderground: "https://www.wunderground.com/weather/gb/london/EGLC",                         defaultModels: null, modelOrder: null },
            { city: "Wellington",   icao: "NZWN", lat: -41.3230, lon: 174.8032,  unit: "celsius",     wunderground: "https://www.wunderground.com/weather/nz/wellington/NZWN",                    defaultModels: null, modelOrder: null },
            { city: "Chicago",      icao: "KORD", lat: 41.9769,  lon: -87.9082,  unit: "fahrenheit",  wunderground: "https://www.wunderground.com/weather/us/il/chicago/KORD",                    defaultModels: null, modelOrder: null },
            { city: "Dallas",       icao: "KDAL", lat: 32.8513,  lon: -96.8635,  unit: "fahrenheit",  wunderground: "https://www.wunderground.com/weather/us/tx/dallas/KDAL",                    defaultModels: null, modelOrder: null },
            { city: "Seoul",        icao: "RKSI", lat: 37.4692,  lon: 126.4506,  unit: "celsius",     wunderground: "https://www.wunderground.com/weather/kr/incheon/RKSI",                      defaultModels: null, modelOrder: null },
            { city: "Buenos Aires", icao: "SAEZ", lat: -34.8222, lon: -58.5358,  unit: "celsius",     wunderground: "https://www.wunderground.com/weather/ar/ezeiza/SAEZ",                       defaultModels: null, modelOrder: null },
            { city: "Sao Paulo",    icao: "SBSP", lat: -23.6261, lon: -46.6564,  unit: "celsius",     wunderground: "https://www.wunderground.com/weather/br/sao-paulo/SBSP",                    defaultModels: null, modelOrder: null },
            { city: "Atlanta",      icao: "KATL", lat: 33.6367,  lon: -84.4279,  unit: "fahrenheit",  wunderground: "https://www.wunderground.com/weather/us/ga/atlanta/KATL",                   defaultModels: null, modelOrder: null }
        ];

        const modelNameMap = {
            "best_match": "Best Match",
            "gfs_hrrr": "HRRR 3km",
            "gfs_graphcast025": "GraphCast AI",
            "ecmwf_ifs025": "ECMWF IFS 25km",
            "icon_seamless": "ICON Seamless",
            "gem_hrdps_continental": "GEM HRDPS 2.5km",
            "jma_seamless": "JMA Seamless",
            "meteofrance_arpege_world": "MeteoFrance Arpege",
            "ukmo_seamless": "UKMO Seamless"
        };

        const modelColors = {
            "Best Match": "#00bcd4",
            "HRRR 3km": "#ff5722",
            "GraphCast AI": "#4caf50",
            "ECMWF IFS 25km": "#9c27b0",
            "ICON Seamless": "#00e676",
            "GEM HRDPS 2.5km": "#ffc107",
            "JMA Seamless": "#e91e63",
            "UKMO Seamless": "#ff9800",
            "MeteoFrance Arpege": "#f57c00"
        };

        // Run definitions for previous runs chart
        const PREVIOUS_RUN_DEFS = [
            { key: 'temperature_2m',              label: 'Current Run',      color: 'rgba(255, 183, 77, 1)',    borderWidth: 3 },
            { key: 'temperature_2m_previous_day1', label: 'Run from 24h ago', color: 'rgba(255, 183, 77, 0.75)', borderWidth: 2 },
            { key: 'temperature_2m_previous_day2', label: 'Run from 48h ago', color: 'rgba(255, 183, 77, 0.55)', borderWidth: 2 },
            { key: 'temperature_2m_previous_day3', label: 'Run from 72h ago', color: 'rgba(255, 183, 77, 0.35)', borderWidth: 2 },
            { key: 'temperature_2m_previous_day4', label: 'Run from 96h ago', color: 'rgba(255, 183, 77, 0.18)', borderWidth: 2 },
        ];

        // State
        let currentLocation = null;
        let forecastCache = new Map();
        let temperatureChart = null;
        let previousRunsChart = null;
        let currentChartData = null;
        let enabledModels = new Set();

        const CACHE_DURATION = 5 * 60 * 1000;

        // DOM elements
        const locationSelect        = document.getElementById('location-select');
        const refreshBtn            = document.getElementById('refresh-btn');
        const forecastBody          = document.getElementById('forecast-body');
        const errorContainer        = document.getElementById('error-container');
        const infoBar               = document.getElementById('info-bar');
        const locationNameEl        = document.getElementById('location-name');
        const temperatureUnitEl     = document.getElementById('temperature-unit');
        const lastUpdatedEl         = document.getElementById('last-updated');
        const wundergroundLink      = document.getElementById('wunderground-link');
        const toggleAllBtn          = document.getElementById('toggle-all-models');
        const modelTogglesContainer = document.getElementById('model-toggles');
        const prevRunsModelSelect   = document.getElementById('previous-runs-model-select');
        const prevRunsLegend        = document.getElementById('previous-runs-legend');
        const prevRunsLoading       = document.getElementById('previous-runs-loading');

        function getModelColor(modelName) {
            return modelColors[modelName] || '#' + Math.floor(Math.random() * 16777215).toString(16);
        }

        function constructURL(location) {
            const baseURL = 'https://api.open-meteo.com/v1/forecast';
            const models = ['best_match','gfs_hrrr','gfs_graphcast025','ecmwf_ifs025',
                            'icon_seamless','gem_hrdps_continental','jma_seamless',
                            'meteofrance_arpege_world','ukmo_seamless'].join(',');
            const params = new URLSearchParams({
                latitude: location.lat, longitude: location.lon,
                hourly: 'temperature_2m', temperature_unit: location.unit,
                timezone: 'auto', forecast_hours: 24, models
            });
            return baseURL + '?' + params.toString();
        }

        function extractModelName(apiKey) {
            const modelKey = apiKey.replace('temperature_2m_', '');
            return modelNameMap[modelKey] || modelKey.toUpperCase();
        }

        function getCachedForecast(city) {
            const cached = forecastCache.get(city);
            if (cached && (Date.now() - cached.timestamp < CACHE_DURATION)) return cached.data;
            return null;
        }

        function setCachedForecast(city, data) {
            forecastCache.set(city, { data, timestamp: Date.now() });
        }

        function displayError(message) {
            errorContainer.innerHTML = `<div class="error"><div class="error-title">&#9888;&#65039; Error</div><div class="error-message">${message}</div></div>`;
        }

        function clearError() { errorContainer.innerHTML = ''; }

        function showLoading() {
            forecastBody.innerHTML = `<tr><td colspan="3" class="loading"><div class="loading-spinner"></div><div>Loading forecast data...</div></td></tr>`;
        }

        function showNoData() {
            forecastBody.innerHTML = `<tr><td colspan="3" class="no-data">No forecast data available for this location.</td></tr>`;
        }

        async function fetchForecast(location) {
            const cached = getCachedForecast(location.city);
            if (cached) return cached;
            const url = constructURL(location);
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                const results = [];
                for (const key in data.hourly) {
                    if (key === 'time') continue;
                    const temps = data.hourly[key];
                    if (temps.every(t => t === null)) continue;
                    const validTemps = temps.filter(t => t !== null);
                    if (!validTemps.length) continue;
                    const maxTemp = Math.max(...validTemps);
                    const maxIndex = temps.indexOf(maxTemp);
                    const timeString = data.hourly.time[maxIndex];
                    const hourlyData = data.hourly.time.map((time, idx) => ({ x: time, y: temps[idx] })).filter(p => p.y !== null);
                    results.push({ model: extractModelName(key), high: maxTemp.toFixed(1), time: timeString, hourlyData });
                }
                results.sort((a, b) => parseFloat(b.high) - parseFloat(a.high));
                setCachedForecast(location.city, results);
                return results;
            } catch (error) {
                console.error('Fetch error:', error);
                throw error;
            }
        }

        function renderTable(results, unit, location) {
            if (!results.length) { showNoData(); return; }
            const unitSymbol = unit === 'celsius' ? '&#176;C' : '&#176;F';
            let sortedResults = [...results];
            if (location.modelOrder) {
                sortedResults.sort((a, b) => {
                    const ia = location.modelOrder.indexOf(a.model);
                    const ib = location.modelOrder.indexOf(b.model);
                    return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
                });
            }
            forecastBody.innerHTML = sortedResults.map(result => {
                const isEnabled = enabledModels.has(result.model);
                const rowStyle = !isEnabled ? 'style="opacity: 0.4"' : '';
                let modelDisplay = result.model;
                if (result.model === "GEM HRDPS 2.5km" && location.city === "Toronto") {
                    modelDisplay = `<a href="https://weather.gc.ca/en/forecast/hourly/index.html?coords=43.712,-79.655" target="_blank" rel="noopener noreferrer" class="model-link">GEM HRDPS 2.5km</a>`;
                }
                return `<tr ${rowStyle}><td>${modelDisplay}</td><td>${result.high}${unitSymbol}</td><td>${result.time}</td></tr>`;
            }).join('');
        }

        function renderChart(results, unit, location) {
            const canvas = document.getElementById('temperature-chart');
            const ctx = canvas.getContext('2d');
            if (temperatureChart) temperatureChart.destroy();
            let sortedResults = [...results];
            if (location.modelOrder) {
                sortedResults.sort((a, b) => {
                    const ia = location.modelOrder.indexOf(a.model);
                    const ib = location.modelOrder.indexOf(b.model);
                    return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
                });
            }
            currentChartData = sortedResults;
            enabledModels.clear();
            sortedResults.forEach(result => {
                const on = location.defaultModels ? location.defaultModels.includes(result.model) : true;
                if (on) enabledModels.add(result.model);
            });
            const datasets = sortedResults.map(result => {
                const on = location.defaultModels ? location.defaultModels.includes(result.model) : true;
                return {
                    label: result.model, data: result.hourlyData,
                    borderColor: getModelColor(result.model),
                    backgroundColor: getModelColor(result.model) + '20',
                    borderWidth: 2, pointRadius: 2, pointHoverRadius: 5,
                    tension: 0.4, fill: false, hidden: !on
                };
            });
            const unitSymbol = unit === 'celsius' ? '°C' : '°F';
            temperatureChart = new Chart(ctx, {
                type: 'line', data: { datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.85)', titleColor: '#fff', bodyColor: '#fff',
                            borderColor: '#ffb74d', borderWidth: 1, displayColors: true, padding: 12,
                            callbacks: {
                                title: ctx => new Date(ctx[0].parsed.x).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true }),
                                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}${unitSymbol}`
                            }
                        }
                    },
                    scales: {
                        x: { type: 'time', time: { unit: 'hour', displayFormats: { hour: 'ha' }, tooltipFormat: 'MMM d, h:mm a' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa', maxRotation: 0, autoSkip: true, maxTicksLimit: 12 } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa', callback: v => v + unitSymbol } }
                    }
                }
            });
            generateModelToggles(sortedResults, location);
        }

        function generateModelToggles(results, location) {
            modelTogglesContainer.innerHTML = '';
            results.forEach((result, index) => {
                const color = getModelColor(result.model);
                const on = location.defaultModels ? location.defaultModels.includes(result.model) : true;
                const div = document.createElement('div');
                div.className = 'model-toggle-item';
                const cb = document.createElement('input');
                cb.type = 'checkbox'; cb.id = `toggle-${index}`; cb.checked = on; cb.dataset.index = index;
                const lbl = document.createElement('label');
                lbl.htmlFor = `toggle-${index}`;
                const dot = document.createElement('span');
                dot.className = 'color-indicator';
                dot.style.backgroundColor = color;
                lbl.appendChild(dot);
                lbl.appendChild(document.createTextNode(result.model));
                div.appendChild(cb); div.appendChild(lbl);
                modelTogglesContainer.appendChild(div);
                cb.addEventListener('change', e => {
                    const idx = parseInt(e.target.dataset.index);
                    toggleDataset(idx, e.target.checked);
                    if (e.target.checked) enabledModels.add(result.model);
                    else enabledModels.delete(result.model);
                    renderTable(currentChartData, currentLocation.unit, currentLocation);
                });
            });
        }

        function toggleDataset(index, visible) {
            if (temperatureChart) {
                temperatureChart.getDatasetMeta(index).hidden = !visible;
                temperatureChart.update();
            }
        }

        function toggleAllModels() {
            const checkboxes = modelTogglesContainer.querySelectorAll('input[type="checkbox"]');
            const anyChecked = Array.from(checkboxes).some(cb => cb.checked);
            const newState = !anyChecked;
            enabledModels.clear();
            checkboxes.forEach((cb, index) => {
                cb.checked = newState;
                toggleDataset(index, newState);
                if (newState && currentChartData) enabledModels.add(currentChartData[index].model);
            });
            if (currentChartData && currentLocation) renderTable(currentChartData, currentLocation.unit, currentLocation);
        }

        function updateInfoBar(location) {
            locationNameEl.textContent = `${location.city} (${location.icao})`;
            temperatureUnitEl.textContent = location.unit === 'celsius' ? 'Celsius' : 'Fahrenheit';
            lastUpdatedEl.textContent = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
            wundergroundLink.href = location.wunderground;
            infoBar.style.display = 'flex';
        }

        // ─── PREVIOUS RUNS API ────────────────────────────────────────────────────
        // Uses https://previous-runs-api.open-meteo.com/v1/forecast
        // A single request returns all runs as parallel variables:
        //   temperature_2m               → current run
        //   temperature_2m_previous_day1 → what the model predicted 24 h ago
        //   temperature_2m_previous_day2 → 48 h ago  … up to previous_day4
        // All arrays share the same time axis (future forecast times), so they
        // can be plotted directly on the same chart for run-to-run comparison.
        async function fetchPreviousRuns(location, modelKey) {
            const variables = PREVIOUS_RUN_DEFS.map(d => d.key).join(',');
            const url = `https://previous-runs-api.open-meteo.com/v1/forecast`
                      + `?latitude=${location.lat}&longitude=${location.lon}`
                      + `&hourly=${variables}`
                      + `&temperature_unit=${location.unit}`
                      + `&timezone=auto`
                      + `&forecast_days=2`
                      + `&models=${modelKey}`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (!data.hourly || !data.hourly.time) return [];

                const now        = Date.now();
                const windowEnd  = now + 24 * 3600 * 1000;

                return PREVIOUS_RUN_DEFS.map(def => {
                    const temps = data.hourly[def.key];
                    if (!temps) return null;

                    const points = data.hourly.time.map((t, i) => {
                        const ms = new Date(t).getTime();
                        if (ms >= now && ms <= windowEnd && temps[i] !== null) {
                            return { x: t, y: temps[i] };
                        }
                        return null;
                    }).filter(Boolean);

                    return points.length ? { label: def.label, data: points } : null;
                }).filter(Boolean);

            } catch (err) {
                console.error('Previous runs fetch error:', err);
                return [];
            }
        }

        function buildPreviousRunsLegend(runs) {
            prevRunsLegend.innerHTML = '';
            runs.forEach((run, i) => {
                const def = PREVIOUS_RUN_DEFS[i] || PREVIOUS_RUN_DEFS[PREVIOUS_RUN_DEFS.length - 1];
                const item = document.createElement('span');
                item.className = 'legend-item';
                item.dataset.index = i;
                item.innerHTML = `<span class="legend-dot" style="background-color:${def.color};"></span>${run.label}`;
                item.addEventListener('click', () => togglePreviousRun(i, item));
                prevRunsLegend.appendChild(item);
            });
        }

        function togglePreviousRun(index, legendItem) {
            if (!previousRunsChart) return;
            const meta = previousRunsChart.getDatasetMeta(index);
            meta.hidden = !meta.hidden;
            previousRunsChart.update();
            legendItem.classList.toggle('disabled', meta.hidden);
        }

        function renderPreviousRunsChart(runs, unit) {
            const canvas = document.getElementById('previous-runs-chart');
            const ctx = canvas.getContext('2d');
            if (previousRunsChart) previousRunsChart.destroy();

            const datasets = runs.map((run, i) => {
                const def = PREVIOUS_RUN_DEFS[i] || PREVIOUS_RUN_DEFS[PREVIOUS_RUN_DEFS.length - 1];
                return {
                    label: run.label, data: run.data,
                    borderColor: def.color, backgroundColor: def.color,
                    borderWidth: def.borderWidth,
                    pointRadius: 0, pointHoverRadius: 4,
                    tension: 0.4, fill: false
                };
            });

            const unitSymbol = unit === 'celsius' ? '°C' : '°F';

            previousRunsChart = new Chart(ctx, {
                type: 'line', data: { datasets },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.85)', titleColor: '#fff', bodyColor: '#fff',
                            borderColor: '#ffb74d', borderWidth: 1, displayColors: true, padding: 12,
                            callbacks: {
                                title: ctx => new Date(ctx[0].parsed.x).toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', hour12: true }),
                                label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}${unitSymbol}`
                            }
                        }
                    },
                    scales: {
                        x: { type: 'time', time: { unit: 'hour', displayFormats: { hour: 'ha' }, tooltipFormat: 'MMM d, h:mm a' }, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa', maxRotation: 0, autoSkip: true, maxTicksLimit: 12 } },
                        y: { grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#aaa', callback: v => v + unitSymbol } }
                    }
                }
            });

            buildPreviousRunsLegend(runs);
        }

        async function refreshPreviousRuns() {
            if (!currentLocation) return;
            prevRunsLoading.classList.add('active');
            try {
                const modelKey = prevRunsModelSelect.value;
                const runs = await fetchPreviousRuns(currentLocation, modelKey);
                if (runs.length > 0) renderPreviousRunsChart(runs, currentLocation.unit);
                else prevRunsLegend.innerHTML = '<span style="color:var(--text-muted);font-size:13px;">No previous run data available for this model.</span>';
            } finally {
                prevRunsLoading.classList.remove('active');
            }
        }
        // ─────────────────────────────────────────────────────────────────────────

        async function fetchAndDisplay(location) {
            currentLocation = location;
            clearError(); showLoading();
            refreshBtn.disabled = true;
            try {
                const results = await fetchForecast(location);
                renderChart(results, location.unit, location);
                renderTable(results, location.unit, location);
                updateInfoBar(location);
                await refreshPreviousRuns();
            } catch (error) {
                displayError('Unable to fetch forecast data. Please check your connection and try again.');
                showNoData();
            } finally {
                refreshBtn.disabled = false;
            }
        }

        locationSelect.addEventListener('change', e => fetchAndDisplay(locations[parseInt(e.target.value)]));
        refreshBtn.addEventListener('click', () => { if (currentLocation) { forecastCache.delete(currentLocation.city); fetchAndDisplay(currentLocation); } });
        toggleAllBtn.addEventListener('click', toggleAllModels);
        prevRunsModelSelect.addEventListener('change', refreshPreviousRuns);

        window.addEventListener('DOMContentLoaded', () => fetchAndDisplay(locations[0]));
    </script>
</body>
</html>
