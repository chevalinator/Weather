<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polymarket Temperature Forecast Dashboard V2.2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        :root {
            --bg-primary:#1a1a1a; --bg-secondary:#2a2a2a; --bg-tertiary:#333333;
            --text-primary:#ffffff; --text-secondary:#aaaaaa; --text-muted:#666666;
            --highlight:#ffb74d; --border:#333333; --error:#ff6b6b; --success:#4caf50;
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family:-apple-system,BlinkMacSystemFont,'Inter','Roboto','Segoe UI',Arial,sans-serif; background-color:var(--bg-primary); color:var(--text-primary); padding:20px; line-height:1.6; }
        .container { max-width:1200px; margin:0 auto; }
        header { text-align:center; margin-bottom:40px; }
        h1 { font-size:28px; font-weight:700; margin-bottom:10px; }
        .subtitle { font-size:14px; color:var(--text-secondary); }
        .controls { background-color:var(--bg-secondary); padding:20px; border-radius:8px; margin-bottom:30px; display:flex; flex-wrap:wrap; gap:15px; align-items:center; }
        .control-group { display:flex; flex-direction:column; gap:8px; flex:1; min-width:200px; }
        label { font-size:13px; font-weight:600; color:var(--text-secondary); text-transform:uppercase; letter-spacing:0.5px; }
        select { padding:12px 16px; font-size:15px; background-color:var(--bg-tertiary); color:var(--text-primary); border:1px solid var(--border); border-radius:6px; cursor:pointer; outline:none; transition:all 0.2s ease; }
        select:hover { border-color:var(--highlight); }
        select:focus { border-color:var(--highlight); box-shadow:0 0 0 3px rgba(255,183,77,0.2); }
        button { padding:12px 24px; font-size:14px; font-weight:600; background-color:var(--highlight); color:var(--bg-primary); border:none; border-radius:6px; cursor:pointer; transition:all 0.2s ease; align-self:flex-end; }
        button:hover { background-color:#ffa726; transform:translateY(-1px); }
        button:active { transform:translateY(0); }
        button:disabled { opacity:0.5; cursor:not-allowed; transform:none; }
        .info-bar { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; padding:12px 16px; background-color:var(--bg-secondary); border-radius:6px; font-size:13px; }
        .info-bar .left { color:var(--text-secondary); }
        .info-bar .right { color:var(--text-muted); }
        .wunderground-link { color:var(--highlight); text-decoration:none; font-weight:600; }
        .wunderground-link:hover { text-decoration:underline; }
        .table-container { background-color:var(--bg-secondary); border-radius:8px; overflow:hidden; box-shadow:0 4px 6px rgba(0,0,0,0.3); margin-bottom:30px; }
        table { width:100%; border-collapse:collapse; }
        thead { background-color:var(--bg-tertiary); }
        th { padding:14px 16px; text-align:left; font-size:12px; font-weight:700; color:var(--text-secondary); text-transform:uppercase; letter-spacing:0.5px; border-bottom:2px solid var(--border); }
        tbody tr { border-bottom:1px solid var(--border); transition:background-color 0.2s ease; }
        tbody tr:hover { background-color:rgba(255,183,77,0.05); }
        tbody tr:last-child { border-bottom:none; }
        td { padding:12px 16px; font-size:15px; vertical-align:top; }
        td:first-child { font-weight:600; color:var(--text-primary); }
        td:nth-child(2) { font-weight:700; font-size:18px; color:var(--highlight); white-space:nowrap; }
        td:last-child { font-family:'Courier New',monospace; font-size:13px; color:var(--text-secondary); white-space:nowrap; }
        .prev-runs-cell { min-width:160px; }
        .prev-run-row { display:flex; align-items:baseline; gap:5px; padding:2px 0; font-size:12px; line-height:1.4; }
        .prev-run-label { color:var(--text-muted); min-width:46px; flex-shrink:0; }
        .prev-run-val { color:var(--text-secondary); font-weight:600; }
        .prev-run-trend { font-weight:700; font-size:11px; }
        .prev-run-trend.up   { color:#ff6b6b; }
        .prev-run-trend.down { color:#4fc3f7; }
        .prev-run-trend.flat { color:var(--text-muted); }
        .prev-run-diff { color:var(--text-muted); font-size:11px; }
        .prev-runs-none { color:var(--text-muted); font-size:12px; }
        .model-link { color:var(--text-primary); text-decoration:none; transition:color 0.2s ease; }
        .model-link:hover { color:var(--highlight); text-decoration:underline; }
        .graph-section { background-color:var(--bg-secondary); border-radius:8px; padding:20px; margin-bottom:30px; }
        .graph-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:20px; flex-wrap:wrap; gap:15px; }
        .graph-header h2 { font-size:20px; font-weight:600; color:var(--text-primary); margin:0; }
        .graph-controls { display:flex; gap:10px; }
        .graph-controls button { padding:8px 16px; font-size:13px; background-color:var(--bg-tertiary); color:var(--text-primary); border:1px solid var(--border); }
        .graph-controls button:hover { background-color:var(--highlight); color:var(--bg-primary); border-color:var(--highlight); }
        .chart-container { position:relative; height:400px; margin-bottom:20px; }
        .model-toggles { display:grid; grid-template-columns:repeat(auto-fill,minmax(200px,1fr)); gap:12px; padding-top:20px; border-top:1px solid var(--border); }
        .model-toggle-item { display:flex; align-items:center; gap:8px; }
        .model-toggle-item input[type="checkbox"] { width:18px; height:18px; cursor:pointer; accent-color:var(--highlight); }
        .model-toggle-item label { display:flex; align-items:center; gap:8px; cursor:pointer; font-size:14px; color:var(--text-secondary); user-select:none; transition:color 0.2s ease; }
        .model-toggle-item label:hover { color:var(--text-primary); }
        .color-indicator { width:24px; height:3px; border-radius:2px; display:inline-block; }
        .loading { text-align:center; padding:60px 20px; color:var(--text-secondary); }
        .loading-spinner { display:inline-block; width:40px; height:40px; border:4px solid var(--bg-tertiary); border-top-color:var(--highlight); border-radius:50%; animation:spin 1s linear infinite; margin-bottom:20px; }
        @keyframes spin { to { transform:rotate(360deg); } }
        .error { background-color:rgba(255,107,107,0.1); border-left:4px solid var(--error); padding:20px; border-radius:6px; margin-bottom:20px; }
        .error-title { font-weight:700; margin-bottom:8px; color:var(--error); }
        .error-message { color:var(--text-secondary); font-size:14px; }
        .no-data { text-align:center; padding:60px 20px; color:var(--text-secondary); }
        .previous-runs-section { background-color:var(--bg-secondary); border-radius:8px; padding:20px; margin-bottom:30px; }
        .previous-runs-header { margin-bottom:15px; }
        .previous-runs-header h2 { font-size:20px; font-weight:600; color:var(--text-primary); margin-bottom:8px; }
        .previous-runs-header .subtitle { font-size:13px; color:var(--text-secondary); line-height:1.5; }
        .previous-runs-controls { display:flex; align-items:center; gap:12px; margin-top:12px; margin-bottom:12px; flex-wrap:wrap; }
        .previous-runs-controls label { font-size:13px; font-weight:600; color:var(--text-secondary); text-transform:uppercase; letter-spacing:0.5px; white-space:nowrap; }
        .previous-runs-controls select { padding:6px 12px; font-size:13px; background-color:var(--bg-tertiary); color:var(--text-primary); border:1px solid var(--border); border-radius:6px; cursor:pointer; }
        .legend-row { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
        .legend-item { display:inline-flex; align-items:center; gap:6px; padding:5px 10px; border-radius:20px; font-size:12px; color:var(--text-secondary); background-color:var(--bg-tertiary); border:1px solid var(--border); cursor:pointer; transition:all 0.2s ease; user-select:none; }
        .legend-item:hover { border-color:var(--highlight); color:var(--text-primary); }
        .legend-item.disabled { opacity:0.35; border-color:var(--border); }
        .legend-item.disabled .legend-dot { background-color:#555 !important; }
        .legend-dot { width:10px; height:10px; border-radius:50%; flex-shrink:0; }
        footer { margin-top:60px; padding-top:30px; border-top:1px solid var(--border); text-align:center; color:var(--text-muted); font-size:13px; }
        footer a { color:var(--highlight); text-decoration:none; }
        footer a:hover { text-decoration:underline; }
        @media (max-width:768px) {
            body { padding:10px; } h1 { font-size:22px; }
            .controls { flex-direction:column; } .control-group { width:100%; min-width:auto; }
            button { width:100%; align-self:stretch; }
            th, td { padding:10px 10px; font-size:13px; }
            td:nth-child(2) { font-size:15px; }
            .info-bar { flex-direction:column; gap:10px; text-align:center; }
            .chart-container { height:300px; }
            .graph-header { flex-direction:column; align-items:flex-start; }
            .graph-controls { width:100%; } .graph-controls button { flex:1; }
            .model-toggles { grid-template-columns:1fr; }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>&#9925; Polymarket Temperature Forecast Dashboard V2.2</h1>
        <p class="subtitle">Compare weather model forecasts for betting decision support</p>
    </header>

    <div class="controls">
        <div class="control-group">
            <label for="location-select">Select Location</label>
            <select id="location-select" aria-label="Location selector">
                <option value="0">Atlanta (KATL)</option>
                <option value="1">London (EGLC)</option>
                <option value="2">Dallas (KDAL)</option>
                <option value="3">Toronto (CYYZ)</option>
                <option value="4">Seoul (RKSI)</option>
                <option value="5">Chicago (KORD)</option>
                <option value="6">Wellington (NZWN)</option>
                <option value="7">Buenos Aires (SAEZ)</option>
                <option value="8">Sao Paulo (SBSP)</option>
            </select>
        </div>
        <button id="refresh-btn" aria-label="Refresh forecast data">&#128260; Refresh</button>
    </div>

    <div id="info-bar" class="info-bar" style="display:none;">
        <div class="left"><strong id="location-name"></strong> &bull; <span id="temperature-unit"></span></div>
        <div class="right">Last updated: <span id="last-updated"></span> &bull; <a id="wunderground-link" href="#" target="_blank" rel="noopener noreferrer" class="wunderground-link">Weather Underground</a> &bull; <a id="polymarket-link" href="#" target="_blank" rel="noopener noreferrer" class="wunderground-link">&#127920; Polymarket</a></div>
    </div>

    <div id="error-container"></div>

    <div class="table-container">
        <table role="table" aria-label="Weather forecast comparison">
            <thead>
                <tr>
                    <th scope="col">Model</th>
                    <th scope="col">Current High</th>
                    <th scope="col">Previous Runs High</th>
                    <th scope="col">Time (ISO 8601)</th>
                </tr>
            </thead>
            <tbody id="forecast-body">
                <tr><td colspan="4" class="loading"><div class="loading-spinner"></div><div>Loading forecast data...</div></td></tr>
            </tbody>
        </table>
    </div>

    <div class="graph-section">
        <div class="graph-header">
            <h2>&#128202; 24-Hour Temperature Forecast</h2>
            <div class="graph-controls"><button id="toggle-all-models">Toggle All</button></div>
        </div>
        <div class="chart-container"><canvas id="temperature-chart"></canvas></div>
        <div class="model-toggles" id="model-toggles"></div>
    </div>

    <div class="previous-runs-section">
        <div class="previous-runs-header">
            <h2>&#128200; Previous Runs (Time-Lagged Ensemble)</h2>
            <p class="subtitle">
                Shows how the forecast for the upcoming 24 hours has evolved over previous model runs.<br>
                <strong>Consistent lines = High Confidence. Widely varying lines = High Uncertainty.</strong>
            </p>
            <div class="previous-runs-controls">
                <label for="previous-runs-model-select">Model:</label>
                <select id="previous-runs-model-select">
                    <option value="best_match">Best Match</option>
                    <option value="gfs_hrrr">HRRR 3km</option>
                    <option value="gem_hrdps_continental">GEM HRDPS 2.5km</option>
                    <option value="ecmwf_ifs025">ECMWF IFS 25km</option>
                    <option value="icon_seamless">ICON Seamless</option>
                    <option value="ukmo_seamless">UKMO Seamless</option>
                    <option value="gfs_seamless">GFS Seamless</option>
                    <option value="meteofrance_seamless">MeteoFrance Seamless</option>
                    <option value="meteofrance_arpege_world">MeteoFrance Arpege</option>
                    <option value="knmi_seamless">KNMI Seamless</option>
                    <option value="kma_seamless">KMA Seamless</option>
                    <option value="bom_access_global">BOM ACCESS-G</option>
                    <option value="jma_seamless">JMA Seamless</option>
                    <option value="gfs_graphcast025">GraphCast AI</option>
                </select>
            </div>
            <div class="legend-row" id="previous-runs-legend"></div>
        </div>
        <div class="chart-container"><canvas id="previous-runs-chart"></canvas></div>
    </div>

    <footer>
        <p>Data from <a href="https://open-meteo.com" target="_blank" rel="noopener noreferrer">Open-Meteo API</a> &bull; Polymarket resolves via <a href="https://www.wunderground.com" target="_blank" rel="noopener noreferrer">Weather Underground</a></p>
        <p style="margin-top:10px;font-size:12px;">This tool shows model forecasts. Actual resolution depends on Weather Underground historical data.</p>
    </footer>
</div>

<script>
    const locations = [
        { city: "Atlanta",      icao: "KATL", lat: 33.6367,  lon: -84.4279,  unit: "fahrenheit", wunderground: "https://www.wunderground.com/weather/us/ga/atlanta/KATL",                         defaultModels: ["HRRR 3km", "Best Match"],                                   modelOrder: ["HRRR 3km", "Best Match", "NAM 3km", "GEM HRDPS 2.5km", "ECMWF IFS", "GFS Seamless", "ICON Seamless", "JMA Seamless", "GraphCast AI"] },
        { city: "London",       icao: "EGLC", lat: 51.5053,  lon: 0.0553,    unit: "celsius",    wunderground: "https://www.wunderground.com/weather/gb/london/EGLC",                            defaultModels: ["UKMO Seamless", "Best Match", "MeteoFrance Seamless"],      modelOrder: ["UKMO Seamless", "Best Match", "MeteoFrance Seamless", "ICON Seamless", "KNMI Seamless", "ECMWF IFS 25km", "GFS Seamless", "JMA Seamless", "GraphCast AI"] },
        { city: "Dallas",       icao: "KDAL", lat: 32.8513,  lon: -96.8635,  unit: "fahrenheit", wunderground: "https://www.wunderground.com/weather/us/tx/dallas/KDAL",                         defaultModels: ["HRRR 3km", "Best Match", "NAM 3km"],                        modelOrder: ["HRRR 3km", "Best Match", "NAM 3km", "GEM HRDPS 2.5km", "ECMWF IFS", "GFS Seamless", "ICON Seamless", "JMA Seamless", "GraphCast AI"] },
        { city: "Toronto",      icao: "CYYZ", lat: 43.712,   lon: -79.655,   unit: "celsius",    wunderground: "https://www.wunderground.com/weather/ca/toronto-pearson-international/CYYZ",     defaultModels: ["GEM HRDPS 2.5km", "HRRR 3km"],                             modelOrder: ["GEM HRDPS 2.5km", "HRRR 3km", "Best Match", "ECMWF IFS 25km", "ICON Seamless", "UKMO Seamless", "MeteoFrance Arpege", "JMA Seamless", "GraphCast AI"] },
        { city: "Seoul",        icao: "RKSI", lat: 37.4692,  lon: 126.4506,  unit: "celsius",    wunderground: "https://www.wunderground.com/weather/kr/incheon/RKSI",                           defaultModels: ["KMA Seamless", "Best Match"],                               modelOrder: ["KMA Seamless", "Best Match", "JMA Seamless", "ICON Seamless", "ECMWF IFS", "GFS Seamless", "MeteoFrance Arpege", "BOM ACCESS-G", "GraphCast AI"] },
        { city: "Chicago",      icao: "KORD", lat: 41.9769,  lon: -87.9082,  unit: "fahrenheit", wunderground: "https://www.wunderground.com/weather/us/il/chicago/KORD",                        defaultModels: ["HRRR 3km", "Best Match", "GEM HRDPS 2.5km", "NAM 3km"],    modelOrder: ["HRRR 3km", "Best Match", "GEM HRDPS 2.5km", "NAM 3km", "ECMWF IFS", "GFS Seamless", "ICON Seamless", "JMA Seamless", "GraphCast AI"] },
        { city: "Wellington",   icao: "NZWN", lat: -41.323,  lon: 174.8032,  unit: "celsius",    wunderground: "https://www.wunderground.com/weather/nz/wellington/NZWN",                        defaultModels: ["Best Match", "ECMWF IFS"],                                  modelOrder: ["Best Match", "ECMWF IFS", "BOM ACCESS-G", "ICON Seamless", "UKMO Seamless", "GFS Seamless", "MeteoFrance Arpege", "JMA Seamless", "GraphCast AI"] },
        { city: "Buenos Aires", icao: "SAEZ", lat: -34.8222, lon: -58.5358,  unit: "celsius",    wunderground: "https://www.wunderground.com/weather/ar/ezeiza/SAEZ",                            defaultModels: ["Best Match", "ECMWF IFS"],                                  modelOrder: ["Best Match", "ECMWF IFS", "ICON Seamless", "UKMO Seamless", "BOM ACCESS-G", "GFS Seamless", "MeteoFrance Arpege", "JMA Seamless", "GraphCast AI"] },
        { city: "Sao Paulo",    icao: "SBSP", lat: -23.6261, lon: -46.6564,  unit: "celsius",    wunderground: "https://www.wunderground.com/weather/br/sao-paulo/SBSP",                         defaultModels: ["Best Match", "ECMWF IFS"],                                  modelOrder: ["Best Match", "ECMWF IFS", "ICON Seamless", "UKMO Seamless", "BOM ACCESS-G", "GFS Seamless", "MeteoFrance Arpege", "JMA Seamless", "GraphCast AI"] }
    ];

    const modelNameMap = {
        "best_match":                "Best Match",
        "gfs_hrrr":                  "HRRR 3km",
        "gfs_graphcast025":          "GraphCast AI",
        "ecmwf_ifs025":              "ECMWF IFS 25km",
        "icon_seamless":             "ICON Seamless",
        "gem_hrdps_continental":     "GEM HRDPS 2.5km",
        "jma_seamless":              "JMA Seamless",
        "meteofrance_arpege_world":  "MeteoFrance Arpege",
        "ukmo_seamless":             "UKMO Seamless",
        "gfs_seamless":              "GFS Seamless",
        "meteofrance_seamless":      "MeteoFrance Seamless",
        "knmi_seamless":             "KNMI Seamless",
        "kma_seamless":              "KMA Seamless",
        "bom_access_global":         "BOM ACCESS-G"
    };

    const modelNameAliases = {
        "ECMWF IFS": "ECMWF IFS 25km"
    };

    const modelColors = {
        "Best Match":            "#00bcd4",
        "HRRR 3km":              "#ff5722",
        "GraphCast AI":          "#4caf50",
        "ECMWF IFS 25km":        "#9c27b0",
        "ICON Seamless":         "#00e676",
        "GEM HRDPS 2.5km":       "#ffc107",
        "JMA Seamless":          "#e91e63",
        "MeteoFrance Arpege":    "#f57c00",
        "UKMO Seamless":         "#ff9800",
        "GFS Seamless":          "#26c6da",
        "MeteoFrance Seamless":  "#ef5350",
        "KNMI Seamless":         "#ab47bc",
        "KMA Seamless":          "#66bb6a",
        "BOM ACCESS-G":          "#8d6e63",
        "NAM 3km":               "#ec407a"
    };

    const FORECAST_MODELS = [
        'best_match', 'gfs_hrrr', 'gfs_graphcast025', 'ecmwf_ifs025',
        'icon_seamless', 'gem_hrdps_continental', 'jma_seamless',
        'meteofrance_arpege_world', 'ukmo_seamless',
        'gfs_seamless', 'meteofrance_seamless', 'knmi_seamless',
        'kma_seamless', 'bom_access_global'
    ];

    const PREVIOUS_RUN_DEFS = [
        { key:'temperature_2m',                label:'Current Run',      color:'rgba(255,183,77,1)',    borderWidth:3 },
        { key:'temperature_2m_previous_day1',  label:'Run from 24h ago', color:'rgba(255,183,77,0.75)', borderWidth:2 },
        { key:'temperature_2m_previous_day2',  label:'Run from 48h ago', color:'rgba(255,183,77,0.55)', borderWidth:2 },
        { key:'temperature_2m_previous_day3',  label:'Run from 72h ago', color:'rgba(255,183,77,0.35)', borderWidth:2 },
        { key:'temperature_2m_previous_day4',  label:'Run from 96h ago', color:'rgba(255,183,77,0.18)', borderWidth:2 },
    ];

    const PREV_DAY_LABELS = { 1:'24h ago', 2:'48h ago', 3:'72h ago', 4:'96h ago' };

    let currentLocation   = null;
    let forecastCache     = new Map();
    let temperatureChart  = null;
    let previousRunsChart = null;
    let currentChartData  = null;
    let enabledModels     = new Set();
    let prevRunsMap       = {};

    const CACHE_DURATION = 5 * 60 * 1000;

    const locationSelect        = document.getElementById('location-select');
    const refreshBtn            = document.getElementById('refresh-btn');
    const forecastBody          = document.getElementById('forecast-body');
    const errorContainer        = document.getElementById('error-container');
    const infoBar               = document.getElementById('info-bar');
    const locationNameEl        = document.getElementById('location-name');
    const temperatureUnitEl     = document.getElementById('temperature-unit');
    const lastUpdatedEl         = document.getElementById('last-updated');
    const wundergroundLink      = document.getElementById('wunderground-link');
    const toggleAllBtn          = document.getElementById('toggle-all-models');
    const modelTogglesContainer = document.getElementById('model-toggles');
    const prevRunsModelSelect   = document.getElementById('previous-runs-model-select');
    const prevRunsLegend        = document.getElementById('previous-runs-legend');

    function getModelColor(n) {
        const resolved = modelNameAliases[n] || n;
        return modelColors[resolved] || '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');
    }

    function resolveModelName(n) { return modelNameAliases[n] || n; }

    function constructURL(location) {
        const params = new URLSearchParams({
            latitude: location.lat, longitude: location.lon,
            hourly: 'temperature_2m', temperature_unit: location.unit,
            timezone: 'auto', forecast_hours: 24, models: FORECAST_MODELS.join(',')
        });
        return 'https://api.open-meteo.com/v1/forecast?' + params;
    }

    function extractModelName(apiKey) {
        const k = apiKey.replace('temperature_2m_', '');
        return modelNameMap[k] || k.toUpperCase();
    }

    function getCachedForecast(city) {
        const c = forecastCache.get(city);
        return (c && Date.now() - c.timestamp < CACHE_DURATION) ? c.data : null;
    }
    function setCachedForecast(city, data) { forecastCache.set(city, { data, timestamp: Date.now() }); }

    function displayError(msg) { errorContainer.innerHTML = `<div class="error"><div class="error-title">&#9888; Error</div><div class="error-message">${msg}</div></div>`; }
    function clearError() { errorContainer.innerHTML = ''; }
    function showLoading() { forecastBody.innerHTML = `<tr><td colspan="4" class="loading"><div class="loading-spinner"></div><div>Loading forecast data...</div></td></tr>`; }
    function showNoData() { forecastBody.innerHTML = `<tr><td colspan="4" class="no-data">No forecast data available for this location.</td></tr>`; }

    async function fetchForecast(location) {
        const cached = getCachedForecast(location.city);
        if (cached) return cached;
        const r = await fetch(constructURL(location));
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        const data = await r.json();
        const results = [];
        for (const key in data.hourly) {
            if (key === 'time') continue;
            const temps = data.hourly[key];
            if (temps.every(t => t === null)) continue;
            const valid = temps.filter(t => t !== null);
            if (!valid.length) continue;
            const maxTemp = Math.max(...valid);
            const maxIdx  = temps.indexOf(maxTemp);
            const hourlyData = data.hourly.time.map((t, i) => ({ x:t, y:temps[i] })).filter(p => p.y !== null);
            results.push({ model: extractModelName(key), high: maxTemp.toFixed(1), time: data.hourly.time[maxIdx], hourlyData });
        }
        results.sort((a, b) => parseFloat(b.high) - parseFloat(a.high));
        setCachedForecast(location.city, results);
        return results;
    }

    async function fetchPrevRunHighs(location) {
        const dayVars = [1,2,3,4].map(n => `temperature_2m_previous_day${n}`).join(',');
        const url = `https://previous-runs-api.open-meteo.com/v1/forecast`
                  + `?latitude=${location.lat}&longitude=${location.lon}`
                  + `&hourly=${dayVars}&temperature_unit=${location.unit}`
                  + `&timezone=auto&forecast_days=2&models=${FORECAST_MODELS.join(',')}`;
        try {
            const r = await fetch(url);
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const data = await r.json();
            if (!data.hourly) return {};
            const now = Date.now(), windowEnd = now + 24 * 3600 * 1000;
            const result = {};
            for (const key in data.hourly) {
                if (key === 'time') continue;
                const match = key.match(/^temperature_2m_previous_day(\d+)(?:_(.+))?$/);
                if (!match) continue;
                const dayNum    = parseInt(match[1]);
                const modelKey  = match[2] || FORECAST_MODELS[0];
                const modelName = modelNameMap[modelKey] || modelKey.toUpperCase();
                const valid = data.hourly[key].map((t, i) => {
                    const ms = new Date(data.hourly.time[i]).getTime();
                    return (ms >= now && ms <= windowEnd && t !== null) ? t : null;
                }).filter(t => t !== null);
                if (valid.length) {
                    if (!result[modelName]) result[modelName] = {};
                    result[modelName][dayNum] = Math.max(...valid).toFixed(1);
                }
            }
            return result;
        } catch(err) {
            console.error('Prev run highs error:', err);
            return {};
        }
    }

    function renderTable(results, unit, location) {
        if (!results.length) { showNoData(); return; }
        const u = unit === 'celsius' ? '°C' : '°F';
        let sorted = [...results];
        if (location.modelOrder) {
            sorted.sort((a, b) => {
                const ra = resolveModelName(a.model), rb = resolveModelName(b.model);
                const orderResolved = location.modelOrder.map(resolveModelName);
                const ia = orderResolved.indexOf(ra), ib = orderResolved.indexOf(rb);
                return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
            });
        }
        forecastBody.innerHTML = sorted.map(result => {
            const isEnabled = enabledModels.has(result.model);
            const rowStyle  = isEnabled ? '' : 'style="opacity:0.4"';
            const modelPrevRuns = prevRunsMap[result.model];
            let prevCellContent;
            if (!modelPrevRuns || !Object.keys(modelPrevRuns).length) {
                prevCellContent = `<span class="prev-runs-none">&#8213; no data</span>`;
            } else {
                const curr = parseFloat(result.high);
                prevCellContent = [1,2,3,4].map(day => {
                    const val = modelPrevRuns[day];
                    if (val === undefined) return '';
                    const diff    = curr - parseFloat(val);
                    const absDiff = Math.abs(diff).toFixed(1);
                    let arrow, cls, diffStr;
                    if (Math.abs(diff) < 0.15) {
                        arrow = '&#8213;'; cls = 'flat'; diffStr = '';
                    } else if (diff > 0) {
                        arrow = '&#8593;'; cls = 'up';   diffStr = `+${absDiff}${u}`;
                    } else {
                        arrow = '&#8595;'; cls = 'down'; diffStr = `&#8722;${absDiff}${u}`;
                    }
                    return `<div class="prev-run-row">
                        <span class="prev-run-label">${PREV_DAY_LABELS[day]}:</span>
                        <span class="prev-run-val">${val}${u}</span>
                        <span class="prev-run-trend ${cls}">${arrow}</span>
                        ${diffStr ? `<span class="prev-run-diff">${diffStr}</span>` : ''}
                    </div>`;
                }).join('');
            }
            return `<tr ${rowStyle}>
                <td>${result.model}</td>
                <td>${result.high}${u}</td>
                <td class="prev-runs-cell">${prevCellContent}</td>
                <td>${result.time}</td>
            </tr>`;
        }).join('');
    }

    function renderChart(results, unit, location) {
        const ctx = document.getElementById('temperature-chart').getContext('2d');
        if (temperatureChart) temperatureChart.destroy();
        let sorted = [...results];
        if (location.modelOrder) {
            sorted.sort((a, b) => {
                const orderResolved = location.modelOrder.map(resolveModelName);
                const ia = orderResolved.indexOf(resolveModelName(a.model));
                const ib = orderResolved.indexOf(resolveModelName(b.model));
                return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib);
            });
        }
        currentChartData = sorted;
        enabledModels.clear();
        sorted.forEach(r => {
            const defaultResolved = (location.defaultModels || []).map(resolveModelName);
            if (location.defaultModels ? defaultResolved.includes(resolveModelName(r.model)) : true)
                enabledModels.add(r.model);
        });
        const u = unit === 'celsius' ? '°C' : '°F';
        const datasets = sorted.map(r => {
            const defaultResolved = (location.defaultModels || []).map(resolveModelName);
            const on = location.defaultModels ? defaultResolved.includes(resolveModelName(r.model)) : true;
            return { label:r.model, r.hourlyData, borderColor:getModelColor(r.model), backgroundColor:getModelColor(r.model)+'20', borderWidth:2, pointRadius:2, pointHoverRadius:5, tension:0.4, fill:false, hidden:!on };
        });
        temperatureChart = new Chart(ctx, {
            type:'line', { datasets },
            options:{
                responsive:true, maintainAspectRatio:false,
                interaction:{ mode:'index', intersect:false },
                plugins:{ legend:{ display:false },
                    tooltip:{ backgroundColor:'rgba(0,0,0,0.85)', titleColor:'#fff', bodyColor:'#fff', borderColor:'#ffb74d', borderWidth:1, displayColors:true, padding:12,
                        callbacks:{
                            title: c => new Date(c[0].parsed.x).toLocaleString('en-US',{ month:'short', day:'numeric', hour:'numeric', minute:'2-digit', hour12:true }),
                            label: c => `${c.dataset.label}: ${c.parsed.y.toFixed(1)}${u}`
                        }
                    }
                },
                scales:{
                    x:{ type:'time', time:{ unit:'hour', displayFormats:{ hour:'ha' }, tooltipFormat:'MMM d, h:mm a' }, grid:{ color:'rgba(255,255,255,0.1)' }, ticks:{ color:'#aaa', maxRotation:0, autoSkip:true, maxTicksLimit:12 } },
                    y:{ grid:{ color:'rgba(255,255,255,0.1)' }, ticks:{ color:'#aaa', callback:v => v+u } }
                }
            }
        });
        generateModelToggles(sorted, location);
    }

    function generateModelToggles(results, location) {
        modelTogglesContainer.innerHTML = '';
        results.forEach((r, i) => {
            const defaultResolved = (location.defaultModels || []).map(resolveModelName);
            const on  = location.defaultModels ? defaultResolved.includes(resolveModelName(r.model)) : true;
            const div = document.createElement('div'); div.className = 'model-toggle-item';
            const cb  = document.createElement('input'); cb.type='checkbox'; cb.id=`toggle-${i}`; cb.checked=on; cb.dataset.index=i;
            const lbl = document.createElement('label'); lbl.htmlFor=`toggle-${i}`;
            const dot = document.createElement('span'); dot.className='color-indicator'; dot.style.backgroundColor=getModelColor(r.model);
            lbl.appendChild(dot); lbl.appendChild(document.createTextNode(r.model));
            div.appendChild(cb); div.appendChild(lbl); modelTogglesContainer.appendChild(div);
            cb.addEventListener('change', e => {
                const idx = parseInt(e.target.dataset.index);
                if (temperatureChart) { temperatureChart.getDatasetMeta(idx).hidden = !e.target.checked; temperatureChart.update(); }
                if (e.target.checked) enabledModels.add(r.model); else enabledModels.delete(r.model);
                renderTable(currentChartData, currentLocation.unit, currentLocation);
            });
        });
    }

    function toggleAllModels() {
        const cbs = modelTogglesContainer.querySelectorAll('input[type="checkbox"]');
        const newState = !Array.from(cbs).some(cb => cb.checked);
        enabledModels.clear();
        cbs.forEach((cb, i) => {
            cb.checked = newState;
            if (temperatureChart) temperatureChart.getDatasetMeta(i).hidden = !newState;
            if (newState && currentChartData) enabledModels.add(currentChartData[i].model);
        });
        if (temperatureChart) temperatureChart.update();
        if (currentChartData && currentLocation) renderTable(currentChartData, currentLocation.unit, currentLocation);
    }

    function generatePolymarketURL(location) {
        const now    = new Date();
        const months = ['january','february','march','april','may','june',
                        'july','august','september','october','november','december'];
        const citySlug = location.city.toLowerCase().replace(/\s+/g, '-');
        return `https://polymarket.com/event/highest-temperature-in-${citySlug}-on-`
             + `${months[now.getMonth()]}-${now.getDate()}-${now.getFullYear()}`;
    }

    function updateInfoBar(location) {
        locationNameEl.textContent    = `${location.city} (${location.icao})`;
        temperatureUnitEl.textContent = location.unit === 'celsius' ? 'Celsius' : 'Fahrenheit';
        lastUpdatedEl.textContent     = new Date().toLocaleTimeString('en-US',{ hour:'2-digit', minute:'2-digit', hour12:true });
        wundergroundLink.href         = location.wunderground;
        document.getElementById('polymarket-link').href = generatePolymarketURL(location);
        infoBar.style.display         = 'flex';
    }

    async function fetchPreviousRuns(location, modelKey) {
        const vars = PREVIOUS_RUN_DEFS.map(d => d.key).join(',');
        const url  = `https://previous-runs-api.open-meteo.com/v1/forecast`
                   + `?latitude=${location.lat}&longitude=${location.lon}`
                   + `&hourly=${vars}&temperature_unit=${location.unit}`
                   + `&timezone=auto&forecast_days=2&models=${modelKey}`;
        try {
            const r = await fetch(url);
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const data = await r.json();
            if (!data.hourly?.time) return [];
            const now = Date.now(), end = now + 24*3600*1000;
            return PREVIOUS_RUN_DEFS.map(def => {
                const temps = data.hourly[def.key];
                if (!temps) return null;
                const points = data.hourly.time.map((t, i) => {
                    const ms = new Date(t).getTime();
                    return (ms >= now && ms <= end && temps[i] !== null) ? { x:t, y:temps[i] } : null;
                }).filter(Boolean);
                return points.length ? { label:def.label, points } : null;
            }).filter(Boolean);
        } catch(e) { console.error('Prev runs chart error:', e); return []; }
    }

    function buildPreviousRunsLegend(runs) {
        prevRunsLegend.innerHTML = '';
        runs.forEach((run, i) => {
            const def  = PREVIOUS_RUN_DEFS[i] || PREVIOUS_RUN_DEFS[PREVIOUS_RUN_DEFS.length-1];
            const item = document.createElement('span');
            item.className = 'legend-item'; item.dataset.index = i;
            item.innerHTML = `<span class="legend-dot" style="background-color:${def.color}"></span>${run.label}`;
            item.addEventListener('click', () => {
                if (!previousRunsChart) return;
                const meta = previousRunsChart.getDatasetMeta(i);
                meta.hidden = !meta.hidden; previousRunsChart.update();
                item.classList.toggle('disabled', meta.hidden);
            });
            prevRunsLegend.appendChild(item);
        });
    }

    function renderPreviousRunsChart(runs, unit) {
        const ctx = document.getElementById('previous-runs-chart').getContext('2d');
        if (previousRunsChart) previousRunsChart.destroy();
        const u = unit === 'celsius' ? '°C' : '°F';
        const datasets = runs.map((run, i) => {
            const def = PREVIOUS_RUN_DEFS[i] || PREVIOUS_RUN_DEFS[PREVIOUS_RUN_DEFS.length-1];
            return { label:run.label, run.data, borderColor:def.color, backgroundColor:def.color, borderWidth:def.borderWidth, pointRadius:0, pointHoverRadius:4, tension:0.4, fill:false };
        });
        previousRunsChart = new Chart(ctx, {
            type:'line', { datasets },
            options:{
                responsive:true, maintainAspectRatio:false,
                interaction:{ mode:'index', intersect:false },
                plugins:{ legend:{ display:false },
                    tooltip:{ backgroundColor:'rgba(0,0,0,0.85)', titleColor:'#fff', bodyColor:'#fff', borderColor:'#ffb74d', borderWidth:1, displayColors:true, padding:12,
                        callbacks:{
                            title: c => new Date(c[0].parsed.x).toLocaleString('en-US',{ month:'short', day:'numeric', hour:'numeric', minute:'2-digit', hour12:true }),
                            label: c => `${c.dataset.label}: ${c.parsed.y.toFixed(1)}${u}`
                        }
                    }
                },
                scales:{
                    x:{ type:'time', time:{ unit:'hour', displayFormats:{ hour:'ha' }, tooltipFormat:'MMM d, h:mm a' }, grid:{ color:'rgba(255,255,255,0.1)' }, ticks:{ color:'#aaa', maxRotation:0, autoSkip:true, maxTicksLimit:12 } },
                    y:{ grid:{ color:'rgba(255,255,255,0.1)' }, ticks:{ color:'#aaa', callback:v => v+u } }
                }
            }
        });
        buildPreviousRunsLegend(runs);
    }

    async function refreshPreviousRuns() {
        if (!currentLocation) return;
        try {
            const runs = await fetchPreviousRuns(currentLocation, prevRunsModelSelect.value);
            if (runs.length) renderPreviousRunsChart(runs, currentLocation.unit);
            else prevRunsLegend.innerHTML = '<span style="color:var(--text-muted);font-size:13px;">No previous run data available for this model.</span>';
        } catch(e) { console.error(e); }
    }

    async function fetchAndDisplay(location) {
        currentLocation = location;
        clearError(); showLoading();
        refreshBtn.disabled = true;
        try {
            const [results, newPrevRunsMap] = await Promise.all([
                fetchForecast(location),
                fetchPrevRunHighs(location)
            ]);
            prevRunsMap = newPrevRunsMap;
            renderChart(results, location.unit, location);
            renderTable(results, location.unit, location);
            updateInfoBar(location);
            refreshPreviousRuns();
        } catch(err) {
            displayError('Unable to fetch forecast data. Please check your connection and try again.');
            showNoData();
        } finally {
            refreshBtn.disabled = false;
        }
    }

    locationSelect.addEventListener('change', e => fetchAndDisplay(locations[parseInt(e.target.value)]));
    refreshBtn.addEventListener('click', () => { if (currentLocation) { forecastCache.delete(currentLocation.city); fetchAndDisplay(currentLocation); } });
    toggleAllBtn.addEventListener('click', toggleAllModels);
    prevRunsModelSelect.addEventListener('change', refreshPreviousRuns);

    window.addEventListener('DOMContentLoaded', () => fetchAndDisplay(locations[0]));
</script>
</body>
</html>
